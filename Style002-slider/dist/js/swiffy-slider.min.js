const swiffyslider = {
    version: "1.6.0",
    init(e = document.body) {
      for (let t of e.querySelectorAll(".swiffy-slider")) this.initSlider(t);
    },
    initSlider(e) {
      for (let t of e.querySelectorAll(".slider-nav")) {
        let i = t.classList.contains("slider-nav-next");
        t.addEventListener("click", () => this.slide(e, i), { passive: true });
      }
      for (let t of e.querySelectorAll(".slider-indicators"))
        t.addEventListener("click", () => this.slideToByIndicator(e));
      this.onSlideEnd(e, () => this.handleIndicators(e), 60);
  
      if (e.classList.contains("slider-nav-autoplay")) {
        const t = e.getAttribute("data-slider-nav-autoplay-interval")
          ? e.getAttribute("data-slider-nav-autoplay-interval")
          : 2500;
        this.autoPlay(e, t, e.classList.contains("slider-nav-autopause"));
      }
      if (["slider-nav-autohide", "slider-nav-animation"].some(t => e.classList.contains(t))) {
        const t = e.getAttribute("data-slider-nav-animation-threshold")
          ? e.getAttribute("data-slider-nav-animation-threshold")
          : 0.3;
        this.setVisibleSlides(e, t);
      }
    },
    setVisibleSlides(e, t = 0.3) {
      let i = new IntersectionObserver(
        t => {
          t.forEach(e => {
            e.isIntersecting ? e.target.classList.add("slide-visible") : e.target.classList.remove("slide-visible");
          });
          e.querySelector(".slider-container > *:first-child").classList.contains("slide-visible")
            ? e.classList.add("slider-item-first-visible")
            : e.classList.remove("slider-item-first-visible");
          e.querySelector(".slider-container > *:last-child").classList.contains("slide-visible")
            ? e.classList.add("slider-item-last-visible")
            : e.classList.remove("slider-item-last-visible");
        },
        { root: e.querySelector(".slider-container"), threshold: t }
      );
      for (let t of e.querySelectorAll(".slider-container > *")) i.observe(t);
    },
    slide(e, t = true) {
      const i = e.querySelector(".slider-container"),
        s = e.classList.contains("slider-nav-page"),
        l = e.classList.contains("slider-nav-noloop"),
        r = e.classList.contains("slider-nav-nodelay"),
        o = i.children,
        n = parseInt(window.getComputedStyle(i).columnGap),
        a = o[0].offsetWidth + n;
      let d = t ? i.scrollLeft + a : i.scrollLeft - a;
      if (s) {
        d = t ? i.scrollLeft + i.offsetWidth : i.scrollLeft - i.offsetWidth;
      }
      if (i.scrollLeft < 1 && !t && !l) {
        d = i.scrollWidth - i.offsetWidth;
      }
      if (i.scrollLeft >= i.scrollWidth - i.offsetWidth && t && !l) {
        d = 0;
      }
      i.scroll({ left: d, behavior: r ? "auto" : "smooth" });
  
      // Obtener el elemento .slider-content dentro del slide actual
      const sliderContent = e.querySelector(".slider-container > .slide-visible .slider-content");
      console.log(sliderContent)
  
      // Remover la clase activo de todos los elementos con la clase .slider-content
      const allSliderContents = document.querySelectorAll(".slider-content");
      allSliderContents.forEach(content => {
        content.classList.remove("activo");
      });
  
      // Agregar clase activo solo al elemento .slider-content actual
      if (sliderContent) {
        sliderContent.classList.add("activo");
      }
    },
    slideToByIndicator(e) {
      const target = window.event.target,
        index = Array.from(target.parentElement.children).indexOf(target),
        slider = e.querySelector(".slider-container").children.length / index;
      this.slideTo(e, slider);
    },
    slideTo(e, targetSlide) {
      const i = e.querySelector(".slider-container"),
        s = parseInt(window.getComputedStyle(i).columnGap),
        l = i.children[0].offsetWidth + s,
        r = e.classList.contains("slider-nav-nodelay");
      i.scroll({ left: l * targetSlide, behavior: r ? "auto" : "smooth" });
    },
    onSlideEnd(e, t, interval = 125) {
      let timeout;
      e.querySelector(".slider-container").addEventListener(
        "scroll",
        () => {
          window.clearTimeout(timeout);
          timeout = setTimeout(t, interval);
        },
        { capture: false, passive: true }
      );
    },
    autoPlay(e, interval, pauseOnHover) {
      interval = interval < 750 ? 750 : interval;
      let autoPlayInterval = setInterval(() => this.slide(e), interval);
  
      const pauseAutoPlay = () => {
        window.clearTimeout(autoPlayInterval);
      };
  
      const resumeAutoPlay = () => {
        this.autoPlay(e, interval, pauseOnHover);
      };
  
      if (pauseOnHover) {
        ["mouseover", "touchstart"].forEach(eventType => {
          e.addEventListener(eventType, () => {
            pauseAutoPlay();
          }, { once: true, passive: true });
        });
  
        ["mouseout", "touchend"].forEach(eventType => {
          e.addEventListener(eventType, () => {
            resumeAutoPlay();
          }, { once: true, passive: true });
        });
      }
  
      return autoPlayInterval;
    },
    handleIndicators(e) {
      if (!e) return;
      const t = e.querySelector(".slider-container"),
        i = t.scrollWidth - t.offsetWidth,
        s = t.scrollLeft / i;
  
      for (let indicator of e.querySelectorAll(".slider-indicators")) {
        let indicators = indicator.children,
          activeIndex = Math.abs(Math.round((indicators.length - 1) * s));
  
        for (let indicator of indicators) {
          indicator.classList.remove("active");
        }
  
        indicators[activeIndex].classList.add("active");
      }
    },
  };
  
  window.swiffyslider = swiffyslider;
  
  if (!document.currentScript.hasAttribute("data-noinit")) {
    if (document.currentScript.hasAttribute("defer")) {
      swiffyslider.init();
    } else {
      document.onreadystatechange = () => {
        if (document.readyState === "interactive") {
          swiffyslider.init();
        }
      };
    }
  }
  